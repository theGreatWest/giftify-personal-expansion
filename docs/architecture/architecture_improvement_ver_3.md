# Giftify 아키텍처 개선 기록 (Version 3)

>`architecture_improvement_ver_2.md`에 정의된 도메인 중심의 Modular Monolith 구조에서 향후 **MSA(Microservices Architecture) 전환**을 고려하여 고도화한 주요 개선 사항을 정리한 문서입니다.

---

## 1. MSA 전환을 고려한 MSA-Ready 구조 도입

### 변경 내용
각 도메인 모듈 간의 결합도를 더욱 낮추고, 향후 개별 서비스로 분리될 때 코드 수정을 최소화할 수 있도록 `api` 패키지 계층을 도입하였습니다.

- **`api` 패키지**: 타 모듈(또는 타 서비스)에서 해당 도메인의 기능을 호출할 때 사용하는 유일한 창구입니다.
- **인터페이스 기반 설계**: 타 모듈은 도메인의 내부 `Service`나 `Port`를 직접 참조하지 않고, `api` 패키지에 정의된 인터페이스만을 참조합니다.

```text
backend/member/
├── api/ (타 모듈용 공개 인터페이스 및 DTO)
│   ├── MemberApi.java (인터페이스)
│   └── dto/
│       └── MemberSummary.java
├── application/ (내부 비즈니스 로직 - MemberUseCase 구현)
├── core/ (도메인 모델)
└── adapter/ (외부 연동 어댑터)
```

### 개선 효과
- **모듈 간 독립성 강화**: 내부 구현(Service, Repository 등)이 변경되어도 `api` 인터페이스만 유지되면 호출 측 코드를 수정할 필요가 없습니다.
- **MSA 전환 용이성**: MSA 전환 시, `api` 인터페이스의 구현체를 로컬 서비스 호출에서 `FeignClient` 등 원격 호출 방식으로 교체하는 것만으로 전환이 가능합니다.

---

## 2. 내부 구현과 외부 노출의 분리

### 변경 내용
기존의 `MemberService`는 핵심 비즈니스 로직(회원가입 등)을 담당하고, `api` 인터페이스의 구현체는 별도의 `ApiService`로 분리하여 서비스 내에서 역할을 명확히 구분하도록 하였습니다.

- **`MemberApiService`**: `MemberApi` 인터페이스를 구현하며, 내부 포트를 통해 데이터를 조회한 뒤 외부 노출용 DTO(`MemberSummary`)로 변환하여 반환하는 역할을 수행합니다.

### 개선 효과
- **보안성 및 캡슐화**: 도메인 엔티티나 내부 DTO가 외부 모듈로 직접 유출되는 것을 방지하고, 필요한 데이터만 정제하여 노출합니다.

---

## 3. 전 도메인 모듈의 API 패키지 표준화

### 변경 내용
`member` 모듈뿐만 아니라 `auth`, `product`, `funding`, `order`, `payment`, `notification`, `search` 등 모든 도메인 모듈에 동일한 `api` 패키지 구조를 생성하여 아키텍처 일관성을 확보하였습니다.

---

## 4. 핵심 설계 원칙 준수 요약

| 원칙 | Version 2 (도메인 중심) | Version 3 (MSA-Ready) |
|------|--------------------|----------------------|
| **모듈 간 통신** | 서비스/포트 직접 참조 가능 | `api` 인터페이스를 통한 간접 참조 |
| **결합도** | 도메인 간 결합 (Low) | 서비스 수준의 분리 가능 (Very Low) |
| **DTO 공유** | 모듈 간 DTO 공유 발생 가능 | `api.dto` 패키지를 통한 명시적 노출 |
| **전환 시나리오** | 모듈 코드 이동 필요 | 구현체 교체 (FeignClient 등)만으로 가능 |
| **패키지 구조** | application/core/adapter | **api**/application/core/adapter |

---

## 5. Controller를 직접 호출하지 않고, API 인터페이스를 만든 이유

헥사고날 아키텍처와 MSA-Ready 관점에서 모듈 간 통신 시 Controller가 아닌 `api` 인터페이스를 사용하는 이유는 다음과 같습니다.

### 1단계: 헥사고날 아키텍처 관점 (관심사의 분리)
- **Controller의 역할 제한**: 헥사고날 아키텍처에서 Controller는 '외부(HTTP 요청)에서 시스템으로 들어오는 입구'인 인바운드 어댑터입니다. 이는 외부 프로토콜(HTTP/REST)에 종속된 계층입니다.
- **내부 호출의 부적절성**: 모듈 내부나 타 모듈에서 직접 Controller를 호출하는 것은, 로컬 자바 호출임에도 불구하고 불필요하게 HTTP 통신 계층을 의존하게 만듭니다.
- **도메인 중심 통신**: `api` 인터페이스를 통해 통신하면, 호출 측은 HTTP와 같은 전송 프로토콜을 신경 쓰지 않고 비즈니스 기능(API)에만 집중할 수 있습니다.

### 2단계: MSA-Ready 관점 (통신 방식의 추상화)
- **위치 투명성(Location Transparency) 확보**: 모듈이 같은 JVM에 있든(Modular Monolith), 별도의 서버에 있든(MSA) 호출 방식이 동일해야 합니다.
- **인터페이스 기반 호출**: 타 모듈이 인터페이스를 바라보게 설계하면, 현재는 로컬 빈(Bean) 호출로 동작하지만 향후 별도 서비스로 분리될 때 구현체만 `FeignClient` 등으로 교체하여 네트워크 호출로 전환할 수 있습니다.
- **의존성 격리**: Controller를 직접 참조하면 호출 측 모듈이 프레임워크 전용 어노테이션(`@RestController`, `@PostMapping` 등)이나 Web 관련 의존성을 강하게 가지게 되지만, 순수 자바 인터페이스인 `api`를 사용하면 이를 방지할 수 있습니다.

### 3단계: 유지보수 및 확장성 관점
- **DTO 분리**: Controller에서 사용하는 Request/Response DTO는 외부 API 스펙에 최적화되어 있습니다. 모듈 간 내부 통신용 인터페이스인 `api`에서 사용하는 DTO를 별도로 관리함으로써, 외부 API 스펙이 변경되어도 내부 모듈 간의 규약은 안정적으로 유지할 수 있습니다.
- **테스트 용이성**: Controller는 MockMvc 등을 통한 무거운 테스트가 필요하지만, `api` 인터페이스는 순수 Mock 객체로 대체하여 비즈니스 로직 테스트를 매우 빠르고 가볍게 수행할 수 있습니다.
